# Langages de programmation, interprétation, compilation

**Projet 2025–26 — Micro Go**
**Partie 1 — 7 novembre 2025**

---

L’objectif de ce projet est de réaliser un interprète (et un compilateur produisant du code MIPS) pour un fragment de Go, appelé **Micro Go** par la suite. Il s’agit d’un fragment relativement petit du langage Go, avec parfois même quelques petites incompatibilités.

Les programmes Go peuvent être exécutés en ligne, par exemple sur le site
[https://www.mycompiler.io/fr/new/go](https://www.mycompiler.io/fr/new/go).
Il est recommandé de tester des programmes simples pour se familiariser avec la syntaxe et la sémantique du langage.

---

## 1. Exemples

Notre langage **Micro Go** comporte un noyau classique de langage de programmation impératif (expressions arithmétiques et logiques, conditionnelles, boucles).
Il permet de définir et utiliser des structures (tableaux avec champs nommés, possiblement récursifs pour représenter des structures chaînées). Comme en C, le langage Go permet de manipuler des valeurs de type structure avec plusieurs champs et dispose d’un mécanisme explicite de pointeurs (expressions `*e` et `&e`). Ici, dans Micro Go, on ne va considérer comme valeur que des pointeurs vers des structures.

Une autre particularité est de pouvoir renvoyer des n-uplets de valeurs comme résultat d’une fonction. Il est alors possible d’utiliser ce n-uplet (qui n’est pas une valeur) dans une affectation multiple ou en argument d’une autre fonction.

Ces différents points sont illustrés par le programme ci-dessous qui effectue la division euclidienne de deux entiers de plusieurs manières différentes.

```go
package main;
import "fmt";

/* a, b entiers naturels, b > 0 */
func div1(a, b int) (int, int) {
    if (a < b) { return 0, a } else {
        x, y := div1(a-b, b);
        return x+1, y;
    }
};

func div2(a, b int) (int, int) {
    q := 0;
    for (a >= b) { q++; a = a - b };
    return q, a;
};

/* Version avec retour d’une structure */
type res struct { quo int; rem int };
func div3(a, b int) *res {
    r := new(res);
    r.quo = 0;
    for (a >= b) { r.quo++; a = a - b };
    r.rem = a;
    return r;
};

func main() {
    fmt.Print(div1(45, 6)); fmt.Print("\n");
    fmt.Print(div2(45, 6)); fmt.Print("\n");
    r := div3(45, 6);
    fmt.Print(r.quo, r.rem); fmt.Print("\n");
    fmt.Print(r); fmt.Print("\n");
};
```

---

## 2. Syntaxe

Dans la suite, nous utilisons les notations suivantes dans les grammaires :

* ⟨règle⟩⋆ : répétition de la règle un nombre quelconque de fois (y compris aucune)
* ⟨règle⟩⋆t : répétition séparée par le terminal t
* ⟨règle⟩+ : au moins une fois
* ⟨règle⟩+t : au moins une fois, séparée par t
* ⟨règle⟩? : optionnelle (0 ou 1 fois)
* ( ... ) : parenthésage
* ... | ... : alternative

Attention à ne pas confondre les symboles de grammaire («⋆», «+», etc.) avec les opérateurs Go correspondants.

---

### 2.1 Analyse lexicale

Les espaces, tabulations et retours chariot sont des blancs.
Les commentaires peuvent être :

* de la forme `/* ... */` (non imbriqués)
* ou `//` jusqu’à la fin de la ligne.

Les identificateurs respectent :

```
<chiffre> ::= 0–9
<alpha> ::= a–z | A–Z | _
<ident> ::= <alpha> (<alpha> | <chiffre>)*
```

**Mots-clés :**
`else`, `false`, `for`, `func`, `if`, `import`, `nil`, `package`, `return`, `struct`, `true`, `type`, `var`

**Constantes :**

```
<hexa> ::= 0–9 | a–f | A–F
<entier> ::= <chiffre>+ | (0x | 0X) <hexa>+
<car> ::= tout caractère ASCII 32–126 sauf \ et "
         | \\ | \" | \n | \t
<chaîne> ::= " <car>* "
```

Les entiers doivent être compris entre −2⁶³ et 2⁶³−1.

---

**Point-virgule automatique (Bonus)**
Micro Go insère un `;` automatique à la fin d’une ligne si le lexème précédent est dans l’ensemble :

```
<ident> | <entier> | <chaîne> | true | false | nil | return | ++ | -- | ) | }
```

Cela impose que le `else` soit sur la même ligne que le bloc précédent, sinon la syntaxe échoue.

---

### 2.2 Analyse syntaxique

La grammaire complète est donnée (figure 1).
Le point d’entrée est `<fichier>`.

Un fichier Micro Go commence par :

```
package main;
(import "fmt";)?
<déclarations>*
EOF
```

Une **déclaration** peut être :

* une **structure** (`type S struct { ... };`)
* une **fonction** (`func f(...) ... { ... };`)

Les types peuvent être `int`, `bool`, `string`, ou `*S` (pointeur vers structure).

Les **instructions** incluent :

* expressions (et ++, --)
* affectations (`x, y = ...` ou `x, y := ...`)
* blocs `{ ... }`
* conditionnelles `if ... else ...`
* déclarations `var ...`
* boucles `for ...`
* retours `return ...`

Les **expressions** incluent :

* constantes (`true`, `false`, `nil`)
* appels de fonctions (`f(...)`, `fmt.Print(...)`)
* opérateurs unaires et binaires (`!`, `-`, `+`, `*`, `/`, `%`, `&&`, `||`, etc.)
* accès champs `e.x`
* `new(S)`

Table de précédence (de la plus faible à la plus forte) :

| opérateur                        | associativité |   |        |
| -------------------------------- | ------------- | - | ------ |
| `                                |               | ` | gauche |
| `&&`                             | gauche        |   |        |
| `==`, `!=`, `>`, `>=`, `<`, `<=` | gauche        |   |        |
| `+`, `-`                         | gauche        |   |        |
| `*`, `/`, `%`                    | gauche        |   |        |
| `-` (unaire), `!`                | —             |   |        |
| `.`                              | gauche        |   |        |

Grammaire formelle (figure 1) — [omise ici pour concision mais présente dans le PDF] — définit toutes les règles `<fichier>`, `<decl>`, `<expr>`, `<instr>`, etc.

---

## 3. Typage statique

Les types possibles :

```
τ ::= int | bool | string | *S
```

Un **contexte de typage Γ** contient les structures, fonctions et variables (`x : τ`).

Une fonction est notée `f(τ1,...,τn) ⇒ τ′1,...,τ′m`.

L’identifiant `_` sert de variable jetable (ne crée pas de binding).

### Bonnes formations

* `Γ ⊢ int bf`, `Γ ⊢ bool bf`, `Γ ⊢ string bf`
* `S ∈ Γ ⇒ Γ ⊢ *S bf`

### Typage des expressions

* constantes : `Γ ⊢ c : τ`
* `nil` : `Γ ⊢ nil : *S`
* variables : `x : τ ∈ Γ ⇒ Γ ⊢ x : τ`
* `new(S)` : `Γ ⊢ new(S) : *S`
* accès champ : `Γ ⊢ e : *S`, `S{x : τ}`, `e ≠ nil ⇒ Γ ⊢ e.x : τ`

Opérations :

* `- e` : int → int
* `! e` : bool → bool
* comparaisons (`==`, `!=`, `<`, `<=`, `>`, `>=`)
* arithmétiques (`+`, `-`, `*`, `/`, `%`)
* logiques (`&&`, `||`)
* appels de fonction : `Γ ⊢ f(e₁,…,eₙ) ⇒ τ₁,…,τₘ`

Règle spéciale : si une fonction retourne une seule valeur, `f(...)` peut être utilisé comme expression.

### Valeurs gauches

`Γ ⊢ₗ e : τ` si `e` est une valeur gauche (ident ou accès champ).

---

### Typage des instructions

* incrément/décrément : `Γ ⊢ₗ e : int ⇒ Γ ⊢ e++`
* `fmt.Print(...)` : tous les `eᵢ` bien typés, ou appel multi-valeurs
* affectation : même nombre et type de valeurs à gauche et à droite
* conditionnelles : `Γ ⊢ e : bool`
* boucles : idem
* `return` : expressions typées selon les types de sortie attendus
* déclarations `var` : types cohérents, pas de `nil` sans type

Les variables locales dans un bloc doivent avoir des noms distincts (sauf `_`).

---

### Typage des blocs et fichiers

Les fonctions et structures peuvent être mutuellement récursives.
Processus conseillé :

1. Ajouter toutes les structures (sans leurs champs).
2. a. Ajouter les fonctions et vérifier la bonne formation des types.
   b. Ajouter les champs des structures et vérifier les types.
3. Vérifier le corps des fonctions (`Γ ⊢ b`), les retours, et que toute variable locale (sauf `_`) est utilisée.

Enfin :

* Vérifier qu’il existe `main()` sans paramètres ni type de retour.
* Vérifier que `import "fmt"` apparaît **iff** il y a un `fmt.Print`.

---

## 4. Travail demandé

Un **squelette de code** est fourni :

| Fichier                | Contenu                                   | Commentaire |
| ---------------------- | ----------------------------------------- | ----------- |
| `mgoast.ml`            | syntaxe abstraite                         | —           |
| `mgolexer.mll`         | analyse lexicale à compléter (ocamllex)   |             |
| `mgoparser.mly`        | analyse grammaticale à compléter (menhir) |             |
| `typechecker.ml`       | vérification des types à compléter        |             |
| `mgoc.ml`              | programme principal                       |             |
| `dune`, `dune-project` | configuration                             |             |
| `tests`                | dossier de tests                          | à compléter |

Votre tâche :
→ Compléter `mgolexer.mll`, `mgoparser.mly` et `typechecker.ml`.
→ Ajouter des tests.
→ Le programme `mgoc` doit être un analyseur complet pour Micro Go.

Travail individuel ou en binôme.
Remise sur **eCampus** sous forme d’archive `.zip` respectant le squelette fourni.
Inclure un **rapport** (README.txt ou PDF) décrivant :

* ce qui fonctionne,
* les difficultés rencontrées,
* les extensions éventuelles.

Tout code emprunté hors cours doit être cité.

**Conseil** : avancer étape par étape — affichage, arithmétique, variables, fonctions, structures.

---

### Utilisation du programme `mgoc`

Commande :

```
mgoc [--parse-only | --type-only] fichier.go
```

* En cas d’erreur lexicale ou syntaxique → message précis :

  ```
  File "test.go", line 4, characters 5-6:
  syntax error
  ```

  (Format compatible avec `next-error` d’Emacs.)

  → code de sortie 1 (`exit 1`).

* Si syntaxe correcte :

  * `--parse-only` : termine avec `exit 0`.
  * Sinon, continue le typage.

* Erreur de typage :

  ```
  File "test.go", line 4, characters 5-6:
  this expression has type int but is expected to have type bool
  ```

  → `exit 1`.

* Aucun problème → `exit 0`.

* Erreur interne du compilateur → `exit 2`.

L’option `--type-only` arrête la compilation après le typage (sans effet pour cette première partie).

